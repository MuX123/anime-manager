[
  {
    "name": "function_search_path_mutable",
    "title": "Function Search Path Mutable",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects functions where the search_path parameter is not set.",
    "detail": "Function \\`public.update_updated_at_column\\` has a role mutable search_path",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0011_function_search_path_mutable",
    "metadata": {
      "name": "update_updated_at_column",
      "type": "function",
      "schema": "public"
    },
    "cache_key": "function_search_path_mutable_public_update_updated_at_column_1489083fd9d99d4554c8e29b3e9a7ad3"
  },
  {
    "name": "function_search_path_mutable",
    "title": "Function Search Path Mutable",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects functions where the search_path parameter is not set.",
    "detail": "Function \\`public.is_admin\\` has a role mutable search_path",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0011_function_search_path_mutable",
    "metadata": {
      "name": "is_admin",
      "type": "function",
      "schema": "public"
    },
    "cache_key": "function_search_path_mutable_public_is_admin_1b5a1d247348c7389a272cca9d8ef964"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.anime_list` has an RLS policy `Allow anonymous operations` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "anime_list",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": "true",
      "policy_name": "Allow anonymous operations",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_anime_list_Allow anonymous operations"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.anime_list` has an RLS policy `Public anime_list` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "anime_list",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": "true",
      "policy_name": "Public anime_list",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_anime_list_Public anime_list"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.anime_list` has an RLS policy `anime_list_full_access` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "anime_list",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": null,
      "policy_name": "anime_list_full_access",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_anime_list_anime_list_full_access"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.announcements` has an RLS policy `Public access` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "announcements",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": "true",
      "policy_name": "Public access",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_announcements_Public access"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.announcements` has an RLS policy `announcements_full_access` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "announcements",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": null,
      "policy_name": "announcements_full_access",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_announcements_announcements_full_access"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.category_clicks` has an RLS policy `Public insert` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "category_clicks",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_category_clicks_Public insert"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.category_clicks` has an RLS policy `Public insert clicks` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "category_clicks",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert clicks",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_category_clicks_Public insert clicks"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.guestbook_messages` has an RLS policy `Public insert guestbook` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "guestbook_messages",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert guestbook",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_guestbook_messages_Public insert guestbook"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.page_views` has an RLS policy `Public insert` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "page_views",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_page_views_Public insert"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.page_views` has an RLS policy `Public insert page_views` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "page_views",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert page_views",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_page_views_Public insert page_views"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.real_time_stats` has an RLS policy `real_time_stats_full_access` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "real_time_stats",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": null,
      "policy_name": "real_time_stats_full_access",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_real_time_stats_real_time_stats_full_access"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.shown_popups` has an RLS policy `Public insert shown_popups` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "shown_popups",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert shown_popups",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_shown_popups_Public insert shown_popups"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.site_settings` has an RLS policy `site_settings_full_access` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "site_settings",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": null,
      "policy_name": "site_settings_full_access",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_site_settings_site_settings_full_access"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.site_visitors` has an RLS policy `Public insert` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "site_visitors",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_site_visitors_Public insert"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.site_visitors` has an RLS policy `Public insert visitors` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "site_visitors",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert visitors",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_site_visitors_Public insert visitors"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.site_visitors` has an RLS policy `Public update` for `UPDATE` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "site_visitors",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "UPDATE",
      "with_check": null,
      "policy_name": "Public update",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_site_visitors_Public update"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.visitor_sessions` has an RLS policy `Public insert` for `INSERT` that allows unrestricted access (WITH CHECK clause is always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "visitor_sessions",
      "qual": null,
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "INSERT",
      "with_check": "true",
      "policy_name": "Public insert",
      "permissive_using": false,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_visitor_sessions_Public insert"
  },
  {
    "name": "rls_policy_always_true",
    "title": "RLS Policy Always True",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Detects RLS policies that use overly permissive expressions like \\`USING (true)\\` or \\`WITH CHECK (true)\\` for UPDATE, DELETE, or INSERT operations. SELECT policies with \\`USING (true)\\` are intentionally excluded as this pattern is often used deliberately for public read access.",
    "detail": "Table `public.visitor_sessions` has an RLS policy `visitor_sessions_full_access` for `ALL` that allows unrestricted access (both USING and WITH CHECK are always true). This effectively bypasses row-level security for -.",
    "remediation": "https://supabase.com/docs/guides/database/database-linter?lint=0024_permissive_rls_policy",
    "metadata": {
      "name": "visitor_sessions",
      "qual": "true",
      "type": "table",
      "roles": [
        "-"
      ],
      "schema": "public",
      "command": "ALL",
      "with_check": null,
      "policy_name": "visitor_sessions_full_access",
      "permissive_using": true,
      "permissive_with_check": true
    },
    "cache_key": "rls_policy_always_true_public_visitor_sessions_visitor_sessions_full_access"
  },
  {
    "name": "auth_leaked_password_protection",
    "title": "Leaked Password Protection Disabled",
    "level": "WARN",
    "facing": "EXTERNAL",
    "categories": [
      "SECURITY"
    ],
    "description": "Leaked password protection is currently disabled.",
    "detail": "Supabase Auth prevents the use of compromised passwords by checking against HaveIBeenPwned.org. Enable this feature to enhance security.",
    "cache_key": "auth_leaked_password_protection",
    "remediation": "https://supabase.com/docs/guides/auth/password-security#password-strength-and-leaked-password-protection",
    "metadata": {
      "type": "auth",
      "entity": "Auth"
    }
  }
]

[
  {
    "query": "with f as (\n      \n-- CTE with sane arg_modes, arg_names, and arg_types.\n-- All three are always of the same length.\n-- All three include all args, including OUT and TABLE args.\nwith functions as (\n  select\n    *,\n    -- proargmodes is null when all arg modes are IN\n    coalesce(\n      p.proargmodes,\n      array_fill($1::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_modes,\n    -- proargnames is null when all args are unnamed\n    coalesce(\n      p.proargnames,\n      array_fill($2::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])\n    ) as arg_names,\n    -- proallargtypes is null when all arg modes are IN\n    coalesce(p.proallargtypes, p.proargtypes) as arg_types,\n    array_cat(\n      array_fill($3, array[pronargs - pronargdefaults]),\n      array_fill($4, array[pronargdefaults])) as arg_has_defaults\n  from\n    pg_proc as p\n  where\n    p.prokind = $5\n)\nselect\n  f.oid as id,\n  n.nspname as schema,\n  f.proname as name,\n  l.lanname as language,\n  case\n    when l.lanname = $6 then $7\n    else f.prosrc\n  end as definition,\n  case\n    when l.lanname = $8 then f.prosrc\n    else pg_get_functiondef(f.oid)\n  end as complete_statement,\n  coalesce(f_args.args, $9) as args,\n  pg_get_function_arguments(f.oid) as argument_types,\n  pg_get_function_identity_arguments(f.oid) as identity_argument_types,\n  f.prorettype as return_type_id,\n  pg_get_function_result(f.oid) as return_type,\n  nullif(rt.typrelid, $10) as return_type_relation_id,\n  f.proretset as is_set_returning_function,\n  case\n    when f.provolatile = $11 then $12\n    when f.provolatile = $13 then $14\n    when f.provolatile = $15 then $16\n  end as behavior,\n  f.prosecdef as security_definer,\n  f_config.config_params as config_params\nfrom\n  functions f\n  left join pg_namespace n on f.pronamespace = n.oid\n  left join pg_language l on f.prolang = l.oid\n  left join pg_type rt on rt.oid = f.prorettype\n  left join (\n    select\n      oid,\n      jsonb_object_agg(param, value) filter (where param is not null) as config_params\n    from\n      (\n        select\n          oid,\n          (string_to_array(unnest(proconfig), $17))[$18] as param,\n          (string_to_array(unnest(proconfig), $19))[$20] as value\n        from\n          functions\n      ) as t\n    group by\n      oid\n  ) f_config on f_config.oid = f.oid\n  left join (\n    select\n      oid,\n      jsonb_agg(jsonb_build_object(\n        $21, t2.mode,\n        $22, name,\n        $23, type_id,\n        -- Cast null into false boolean\n        $24, COALESCE(has_default, $25)\n      )) as args\n    from\n      (\n        select\n          oid,\n          unnest(arg_modes) as mode,\n          unnest(arg_names) as name,\n          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume\n          -- integer, we need to cast it to be properly parsed\n          unnest(arg_types)::int8 as type_id,\n          unnest(arg_has_defaults) as has_default\n        from\n          functions\n      ) as t1,\n      lateral (\n        select\n          case\n            when t1.mode = $26 then $27\n            when t1.mode = $28 then $29\n            when t1.mode = $30 then $31\n            when t1.mode = $32 then $33\n            else $34\n          end as mode\n      ) as t2\n    group by\n      t1.oid\n  ) f_args on f_args.oid = f.oid\n\n    )\n    select\n      f.*\n    from f\n   where schema NOT IN ($35,$36,$37)\n\n-- source: dashboard\n-- user: 695f4cee-7bdb-4380-8d90-f0af7a17006c\n-- date: 2026-01-18T19:55:42.301Z",
    "rolname": "postgres",
    "calls": 308,
    "mean_time": 224.708369834416,
    "min_time": 117.18257,
    "max_time": 1144.434576,
    "total_time": 69210.177909,
    "rows_read": 34909,
    "cache_hit_rate": "99.9982828196102001",
    "prop_total_time": 37.218788119970746,
    "index_advisor_result": null
  },
  {
    "query": "SELECT name FROM pg_timezone_names",
    "rolname": "authenticator",
    "calls": 94,
    "mean_time": 391.428339755319,
    "min_time": 53.136569,
    "max_time": 1403.036761,
    "total_time": 36794.263937,
    "rows_read": 112236,
    "cache_hit_rate": "0",
    "prop_total_time": 19.78665501051116,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n  e.name,\n  n.nspname AS schema,\n  e.default_version,\n  x.extversion AS installed_version,\n  e.comment\nFROM\n  pg_available_extensions() e(name, default_version, comment)\n  LEFT JOIN pg_extension x ON e.name = x.extname\n  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid\nWHERE\n  $1",
    "rolname": "postgres",
    "calls": 339,
    "mean_time": 101.764334212389,
    "min_time": 2.288075,
    "max_time": 1121.78538,
    "total_time": 34498.109298,
    "rows_read": 26442,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 18.551864180873434,
    "index_advisor_result": null
  },
  {
    "query": "WITH pgrst_source AS ( SELECT \"public\".\"anime_list\".* FROM \"public\".\"anime_list\"  ORDER BY \"public\".\"anime_list\".\"created_at\" DESC  LIMIT $1 OFFSET $2 )  SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",
    "rolname": "authenticated",
    "calls": 3114,
    "mean_time": 2.90307844412331,
    "min_time": 0.022039,
    "max_time": 84.424365,
    "total_time": 9040.18627500002,
    "rows_read": 3114,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 4.861492741381032,
    "index_advisor_result": null
  },
  {
    "query": "SELECT\n    tbl.schemaname,\n    tbl.tablename,\n    tbl.quoted_name,\n    tbl.is_table,\n    json_agg(a) as columns\n  FROM\n    (\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $1 || quote_ident(c.relname)) as quoted_name,\n        $2 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind = $3\n        AND n.nspname not in ($4, $5, $6)\n        AND n.nspname not like $7\n        AND n.nspname not like $8\n        AND has_schema_privilege(n.oid, $9) = $10\n        AND has_table_privilege(quote_ident(n.nspname) || $11 || quote_ident(c.relname), $12) = $13\n      union all\n      SELECT\n        n.nspname as schemaname,\n        c.relname as tablename,\n        (quote_ident(n.nspname) || $14 || quote_ident(c.relname)) as quoted_name,\n        $15 as is_table\n      FROM\n        pg_catalog.pg_class c\n        JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n      WHERE\n        c.relkind in ($16, $17)\n        AND n.nspname not in ($18, $19, $20)\n        AND n.nspname not like $21\n        AND n.nspname not like $22\n        AND has_schema_privilege(n.oid, $23) = $24\n        AND has_table_privilege(quote_ident(n.nspname) || $25 || quote_ident(c.relname), $26) = $27\n    ) as tbl\n    LEFT JOIN (\n      SELECT\n        attrelid,\n        attname,\n        format_type(atttypid, atttypmod) as data_type,\n        attnum,\n        attisdropped\n      FROM\n        pg_attribute\n    ) as a ON (\n      a.attrelid = tbl.quoted_name::regclass\n      AND a.attnum > $28\n      AND NOT a.attisdropped\n      AND has_column_privilege(tbl.quoted_name, a.attname, $29)\n    )\n  \n  GROUP BY schemaname, tablename, quoted_name, is_table",
    "rolname": "postgres",
    "calls": 301,
    "mean_time": 25.192567564784,
    "min_time": 5.155761,
    "max_time": 415.34959,
    "total_time": 7582.962837,
    "rows_read": 11972,
    "cache_hit_rate": "99.9991765277468976",
    "prop_total_time": 4.077849467790699,
    "index_advisor_result": null
  },
  {
    "query": "WITH pgrst_source AS ( SELECT \"public\".\"anime_list\".* FROM \"public\".\"anime_list\"  ORDER BY \"public\".\"anime_list\".\"created_at\" DESC  LIMIT $1 OFFSET $2 )  SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",
    "rolname": "anon",
    "calls": 185,
    "mean_time": 18.7695203135135,
    "min_time": 0.012823,
    "max_time": 111.14407,
    "total_time": 3472.361258,
    "rows_read": 185,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.8673131877716391,
    "index_advisor_result": null
  },
  {
    "query": "with table_privileges as (\n-- Despite the name `table_privileges`, this includes other kinds of relations:\n-- views, matviews, etc. \"Relation privileges\" just doesn't roll off the tongue.\n--\n-- For each relation, get its relacl in a jsonb format,\n-- e.g.\n--\n-- '{postgres=arwdDxt/postgres}'\n--\n-- becomes\n--\n-- [\n--   {\n--     \"grantee\": \"postgres\",\n--     \"grantor\": \"postgres\",\n--     \"is_grantable\": false,\n--     \"privilege_type\": \"INSERT\"\n--   },\n--   ...\n-- ]\nselect\n  c.oid as relation_id,\n  nc.nspname as schema,\n  c.relname as name,\n  case\n    when c.relkind = $1 then $2\n    when c.relkind = $3 then $4\n    when c.relkind = $5 then $6\n    when c.relkind = $7 then $8\n    when c.relkind = $9 then $10\n  end as kind,\n  coalesce(\n    jsonb_agg(\n      jsonb_build_object(\n        $11, grantor.rolname,\n        $12, grantee.rolname,\n        $13, _priv.privilege_type,\n        $14, _priv.is_grantable\n      )\n    ) filter (where _priv is not null),\n    $15\n  ) as privileges\nfrom pg_class c\njoin pg_namespace as nc\n  on nc.oid = c.relnamespace\nleft join lateral (\n  select grantor, grantee, privilege_type, is_grantable\n  from aclexplode(coalesce(c.relacl, acldefault($16, c.relowner)))\n) as _priv on $17\nleft join pg_roles as grantor\n  on grantor.oid = _priv.grantor\nleft join (\n  select\n    pg_roles.oid,\n    pg_roles.rolname\n  from pg_roles\n  union all\n  select\n    ($18)::oid as oid, $19\n) as grantee (oid, rolname)\n  on grantee.oid = _priv.grantee\nwhere c.relkind in ($20, $21, $22, $23, $24)\n  and not pg_is_other_temp_schema(c.relnamespace)\n  and (\n    pg_has_role(c.relowner, $25)\n    or has_table_privilege(\n      c.oid,\n      $26\n      || case when current_setting($27)::int4 >= $28 then $29 else $30 end\n    )\n    or has_any_column_privilege(c.oid, $31)\n  )\ngroup by\n  c.oid,\n  nc.nspname,\n  c.relname,\n  c.relkind\n)\nselect *\nfrom table_privileges\n where schema NOT IN ($32,$33,$34)\n\n-- source: dashboard\n-- user: 695f4cee-7bdb-4380-8d90-f0af7a17006c\n-- date: 2026-01-26T08:23:47.031Z",
    "rolname": "postgres",
    "calls": 37,
    "mean_time": 89.6632783243243,
    "min_time": 65.009434,
    "max_time": 205.144041,
    "total_time": 3317.541298,
    "rows_read": 1580,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.7840564838868624,
    "index_advisor_result": null
  },
  {
    "query": "WITH pgrst_source AS ( SELECT \"public\".\"anime_list\".* FROM \"public\".\"anime_list\"  ORDER BY \"public\".\"anime_list\".\"created_at\" DESC  LIMIT $1 OFFSET $2 )  SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",
    "rolname": "authenticated",
    "calls": 213,
    "mean_time": 15.0212513615023,
    "min_time": 0.014449,
    "max_time": 159.667767,
    "total_time": 3199.52654,
    "rows_read": 213,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.7205923171163786,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $3), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $4), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $5\n),\narguments AS (\n  SELECT\n    oid,\n    array_agg((\n      COALESCE(name, $6), -- name\n      type::regtype::text, -- type\n      CASE type\n        WHEN $7::regtype THEN $8\n        WHEN $9::regtype THEN $10\n        WHEN $11::regtype THEN $12\n        WHEN $13::regtype THEN $14\n        ELSE type::regtype::text\n      END, -- convert types that ignore the length and accept any value till maximum size\n      idx <= (pronargs - pronargdefaults), -- is_required\n      COALESCE(mode = $15, $16) -- is_variadic\n    ) ORDER BY idx) AS args,\n    CASE COUNT(*) - COUNT(name) -- number of unnamed arguments\n      WHEN $17 THEN $18\n      WHEN $19 THEN (array_agg(type))[$20] IN ($21::regtype, $22::regtype, $23::regtype, $24::regtype, $25::regtype)\n      ELSE $26\n    END AS callable\n  FROM pg_proc,\n       unnest(proargnames, proargtypes, proargmodes)\n         WITH ORDINALITY AS _ (name, type, mode, idx)\n  WHERE type IS NOT NULL -- only input arguments\n  GROUP BY oid\n)\nSELECT\n  pn.nspname AS proc_schema,\n  p.proname AS proc_name,\n  d.description AS proc_description,\n  COALESCE(a.args, $27) AS args,\n  tn.nspname AS schema,\n  COALESCE(comp.relname, t.typname) AS name,\n  p.proretset AS rettype_is_setof,\n  (t.typtype = $28\n   -- if any TABLE, INOUT or OUT arguments present, treat as composite\n   or COALESCE(proargmodes::text[] && $29, $30)\n  ) AS rettype_is_composite,\n  bt.oid <> bt.base_type as rettype_is_composite_alias,\n  p.provolatile,\n  p.provariadic > $31 as hasvariadic,\n  lower((regexp_split_to_array((regexp_split_to_array(iso_config, $32))[$33], $34))[$35]) AS transaction_isolation_level,\n  coalesce(func_settings.kvs, $36) as kvs\nFROM pg_proc p\nLEFT JOIN arguments a ON a.oid = p.oid\nJOIN pg_namespace pn ON pn.oid = p.pronamespace\nJOIN base_types bt ON bt.oid = p.prorettype\nJOIN pg_type t ON t.oid = bt.base_type\nJOIN pg_namespace tn ON tn.oid = t.typnamespace\nLEFT JOIN pg_class comp ON comp.oid = t.typrelid\nLEFT JOIN pg_description as d ON d.objoid = p.oid AND d.classoid = $37::regclass\nLEFT JOIN LATERAL unnest(proconfig) iso_config ON iso_config LIKE $38\nLEFT JOIN LATERAL (\n  SELECT\n    array_agg(row(\n      substr(setting, $39, strpos(setting, $40) - $41),\n      substr(setting, strpos(setting, $42) + $43)\n    )) as kvs\n  FROM unnest(proconfig) setting\n  WHERE setting ~ ANY($2)\n) func_settings ON $44\nWHERE t.oid <> $45::regtype AND COALESCE(a.callable, $46)\nAND prokind = $47\nAND p.pronamespace = ANY($1::regnamespace[])",
    "rolname": "authenticator",
    "calls": 94,
    "mean_time": 30.904050287234,
    "min_time": 17.989771,
    "max_time": 96.963542,
    "total_time": 2904.980727,
    "rows_read": 97,
    "cache_hit_rate": "99.8694373037932815",
    "prop_total_time": 1.5621959867372601,
    "index_advisor_result": null
  },
  {
    "query": "WITH pgrst_source AS ( SELECT \"public\".\"anime_list\".* FROM \"public\".\"anime_list\"  ORDER BY \"public\".\"anime_list\".\"created_at\" DESC  LIMIT $1 OFFSET $2 )  SELECT $3::bigint AS total_result_set, pg_catalog.count(_postgrest_t) AS page_total, coalesce(json_agg(_postgrest_t), $4) AS body, nullif(current_setting($5, $6), $7) AS response_headers, nullif(current_setting($8, $9), $10) AS response_status, $11 AS response_inserted FROM ( SELECT * FROM pgrst_source ) _postgrest_t",
    "rolname": "anon",
    "calls": 1077,
    "mean_time": 2.59194940482823,
    "min_time": 0.023312,
    "max_time": 40.272168,
    "total_time": 2791.529509,
    "rows_read": 1077,
    "cache_hit_rate": "99.9316727747065035",
    "prop_total_time": 1.5011859305249133,
    "index_advisor_result": null
  },
  {
    "query": "-- Adapted from information_schema.schemata\n\nselect\n  n.oid as id,\n  n.nspname as name,\n  u.rolname as owner,\n   obj_description(n.oid, $1) AS comment\nfrom\n  pg_namespace n,\n  pg_roles u\nwhere\n  n.nspowner = u.oid\n  and (\n    pg_has_role(n.nspowner, $2)\n    or has_schema_privilege(n.oid, $3)\n  )\n  and not pg_catalog.starts_with(n.nspname, $4)\n  and not pg_catalog.starts_with(n.nspname, $5)\n and not (n.nspname in ($6,$7,$8))\n\n-- source: dashboard\n-- user: 695f4cee-7bdb-4380-8d90-f0af7a17006c\n-- date: 2026-01-18T19:53:00.648Z",
    "rolname": "postgres",
    "calls": 374,
    "mean_time": 7.00214761497326,
    "min_time": 0.757625,
    "max_time": 68.283067,
    "total_time": 2618.803208,
    "rows_read": 3366,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 1.4082998291755144,
    "index_advisor_result": null
  },
  {
    "query": "CREATE OR REPLACE FUNCTION pg_temp.count_estimate(\n    query text\n) RETURNS integer LANGUAGE plpgsql AS $$\nDECLARE\n    plan jsonb;\nBEGIN\n    EXECUTE 'EXPLAIN (FORMAT JSON)' || query INTO plan;\n    RETURN plan->0->'Plan'->'Plan Rows';\nEND;\n$$",
    "rolname": "postgres",
    "calls": 142,
    "mean_time": 14.5487421760563,
    "min_time": 2.350529,
    "max_time": 65.065705,
    "total_time": 2065.921389,
    "rows_read": 0,
    "cache_hit_rate": "99.9921128389836079",
    "prop_total_time": 1.1109795231390072,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"refresh_tokens\" (\"created_at\", \"instance_id\", \"parent\", \"revoked\", \"session_id\", \"token\", \"updated_at\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8) returning id",
    "rolname": "supabase_auth_admin",
    "calls": 246,
    "mean_time": 7.20920783739838,
    "min_time": 0.081519,
    "max_time": 35.141065,
    "total_time": 1773.465128,
    "rows_read": 246,
    "cache_hit_rate": "99.8702185792349727",
    "prop_total_time": 0.9537068799906299,
    "index_advisor_result": null
  },
  {
    "query": "SELECT case when pg_is_in_recovery() then $2 else (pg_walfile_name_offset(lsn)).file_name end, lsn::text, pg_is_in_recovery() FROM pg_backup_start($1, $3) lsn",
    "rolname": "supabase_admin",
    "calls": 7,
    "mean_time": 222.873247,
    "min_time": 121.428268,
    "max_time": 646.434433,
    "total_time": 1560.112729,
    "rows_read": 7,
    "cache_hit_rate": "0",
    "prop_total_time": 0.8389734986704835,
    "index_advisor_result": null
  },
  {
    "query": "select set_config('search_path', $1, true), set_config($2, $3, true), set_config('role', $4, true), set_config('request.jwt.claims', $5, true), set_config('request.method', $6, true), set_config('request.path', $7, true), set_config('request.headers', $8, true), set_config('request.cookies', $9, true)",
    "rolname": "authenticated",
    "calls": 11591,
    "mean_time": 0.127658481753084,
    "min_time": 0.018683,
    "max_time": 39.240136,
    "total_time": 1479.689462,
    "rows_read": 11591,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.7957247074547684,
    "index_advisor_result": null
  },
  {
    "query": "with base_table_info as ( select c.oid::int8 as id, nc.nspname as schema, c.relname as name, c.relkind, c.relrowsecurity as rls_enabled, c.relforcerowsecurity as rls_forced, c.relreplident, c.relowner, obj_description(c.oid) as comment, fs.srvname as foreign_server_name, fdw.fdwname as foreign_data_wrapper_name, fdw_handler.proname as foreign_data_wrapper_handler from pg_class c join pg_namespace nc on nc.oid = c.relnamespace left join pg_foreign_table ft on ft.ftrelid = c.oid left join pg_foreign_server fs on fs.oid = ft.ftserver left join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw left join pg_proc fdw_handler on fdw.fdwhandler = fdw_handler.oid where c.oid = $1 and not pg_is_other_temp_schema(nc.oid) and ( pg_has_role(c.relowner, $2) or has_table_privilege( c.oid, $3 ) or has_any_column_privilege(c.oid, $4) ) ), table_stats as ( select b.id, case when b.relreplident = $5 then $6 when b.relreplident = $7 then $8 when b.relreplident = $9 then $10 else $11 end as replica_identity, pg_total_relation_size(format($12, b.schema, b.name))::int8 as bytes, pg_size_pretty(pg_total_relation_size(format($13, b.schema, b.name))) as size, pg_stat_get_live_tuples(b.id) as live_rows_estimate, pg_stat_get_dead_tuples(b.id) as dead_rows_estimate from base_table_info b where b.relkind in ($14, $15) ), primary_keys as ( select i.indrelid as table_id, jsonb_agg( jsonb_build_object( $16, n.nspname, $17, c.relname, $18, i.indrelid::int8, $19, a.attname ) order by array_position(i.indkey, a.attnum) ) as primary_keys from pg_index i join pg_class c on i.indrelid = c.oid join pg_namespace n on c.relnamespace = n.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisprimary group by i.indrelid ), index_cols as ( select i.indrelid as table_id, i.indkey, array_agg( a.attname order by array_position(i.indkey, a.attnum) ) as columns from pg_index i join pg_class c on i.indrelid = c.oid join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey) where i.indisunique and i.indisprimary = $20 group by i.indrelid, i.indkey ), unique_indexes as ( select ic.table_id, jsonb_agg( jsonb_build_object( $21, n.nspname, $22, c.relname, $23, ic.table_id::int8, $24, ic.columns ) ) as unique_indexes from index_cols ic join pg_class c on c.oid = ic.table_id join pg_namespace n on n.oid = c.relnamespace group by ic.table_id ), relationships as ( select c.conrelid as source_id, c.confrelid as target_id, jsonb_build_object( $25, c.oid::int8, $26, c.conname, $27, c.confdeltype, $28, c.confupdtype, $29, nsa.nspname, $30, csa.relname, $31, sa.attname, $32, nta.nspname, $33, cta.relname, $34, ta.attname ) as rel_info from pg_constraint c join pg_class csa on c.conrelid = csa.oid join pg_namespace nsa on csa.relnamespace = nsa.oid join pg_attribute sa on (sa.attrelid = c.conrelid and sa.attnum = any(c.conkey)) join pg_class cta on c.confrelid = cta.oid join pg_namespace nta on cta.relnamespace = nta.oid join pg_attribute ta on (ta.attrelid = c.confrelid and ta.attnum = any(c.confkey)) where c.contype = $35 ), columns as ( select a.attrelid as table_id, jsonb_agg(jsonb_build_object( $36, (a.attrelid || $37 || a.attnum), $38, c.oid::int8, $39, nc.nspname, $40, c.relname, $41, a.attnum, $42, a.attname, $43, case when a.atthasdef then pg_get_expr(ad.adbin, ad.adrelid) else $44 end, $45, case when t.typtype = $46 then case when bt.typelem <> $47::oid and bt.typlen = $48 then $49 when nbt.nspname = $50 then format_type(t.typbasetype, $51) else $52 end else case when t.typelem <> $53::oid and t.typlen = $54 then $55 when nt.nspname = $56 then format_type(a.atttypid, $57) else $58 end end, $59, case when t.typtype = $60 then case when nt.nspname <> $61 then concat(nt.nspname, $62, coalesce(bt.typname, t.typname)) else coalesce(bt.typname, t.typname) end else coalesce(bt.typname, t.typname) end, $63, a.attidentity in ($64, $65), $66, case a.attidentity when $67 then $68 when $69 then $70 else $71 end, $72, a.attgenerated in ($73), $74, not (a.attnotnull or t.typtype = $75 and t.typnotnull), $76, ( b.relkind in ($77, $78) or (b.relkind in ($79, $80) and pg_column_is_updatable(b.id, a.attnum, $81)) ), $82, uniques.table_id is not null, $83, check_constraints.definition, $84, col_description(c.oid, a.attnum), $85, coalesce( ( select jsonb_agg(e.enumlabel order by e.enumsortorder) from pg_catalog.pg_enum e where e.enumtypid = coalesce(bt.oid, t.oid) or e.enumtypid = coalesce(bt.typelem, t.typelem) ), $86::jsonb ) ) order by a.attnum) as columns from pg_attribute a join base_table_info b on a.attrelid = b.id join pg_class c on a.attrelid = c.oid join pg_namespace nc on c.relnamespace = nc.oid left join pg_attrdef ad on (a.attrelid = ad.adrelid and a.attnum = ad.adnum) join pg_type t on a.atttypid = t.oid join pg_namespace nt on t.typnamespace = nt.oid left join pg_type bt on (t.typtype = $87 and t.typbasetype = bt.oid) left join pg_namespace nbt on bt.typnamespace = nbt.oid left join ( select conrelid as table_id, conkey[$88] as ordinal_position from pg_catalog.pg_constraint where contype = $89 and cardinality(conkey) = $90 group by conrelid, conkey[1] ) as uniques on uniques.table_id = a.attrelid and uniques.ordinal_position = a.attnum left join ( select distinct on (conrelid, conkey[1]) conrelid as table_id, conkey[$91] as ordinal_position, substring( pg_get_constraintdef(oid, $92), $93, length(pg_get_constraintdef(oid, $94)) - $95 ) as definition from pg_constraint where contype = $96 and cardinality(conkey) = $97 order by conrelid, conkey[1], oid asc ) as check_constraints on check_constraints.table_id = a.attrelid and check_constraints.ordinal_position = a.attnum where a.attnum > $98 and not a.attisdropped group by a.attrelid ) select case b.relkind when $99 then jsonb_build_object( $100, b.relkind, $101, b.id, $102, b.schema, $103, b.name, $104, b.rls_enabled, $105, b.rls_forced, $106, ts.replica_identity, $107, ts.bytes, $108, ts.size, $109, ts.live_rows_estimate, $110, ts.dead_rows_estimate, $111, b.comment, $112, coalesce(pk.primary_keys, $113::jsonb), $114, coalesce(ui.unique_indexes, $115::jsonb), $116, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $117::jsonb ), $118, coalesce(c.columns, $119::jsonb) ) when $120 then jsonb_build_object( $121, b.relkind, $122, b.id, $123, b.schema, $124, b.name, $125, b.rls_enabled, $126, b.rls_forced, $127, ts.replica_identity, $128, ts.bytes, $129, ts.size, $130, ts.live_rows_estimate, $131, ts.dead_rows_estimate, $132, b.comment, $133, coalesce(pk.primary_keys, $134::jsonb), $135, coalesce(ui.unique_indexes, $136::jsonb), $137, coalesce( (select jsonb_agg(r.rel_info) from relationships r where r.source_id = b.id or r.target_id = b.id), $138::jsonb ), $139, coalesce(c.columns, $140::jsonb) ) when $141 then jsonb_build_object( $142, b.relkind, $143, b.id, $144, b.schema, $145, b.name, $146, (pg_relation_is_updatable(b.id, $147) & $148) = $149, $150, b.comment, $151, coalesce(c.columns, $152::jsonb) ) when $153 then jsonb_build_object( $154, b.relkind, $155, b.id, $156, b.schema, $157, b.name, $158, $159, $160, b.comment, $161, coalesce(c.columns, $162::jsonb) ) when $163 then jsonb_build_object( $164, b.relkind, $165, b.id, $166, b.schema, $167, b.name, $168, b.comment, $169, b.foreign_server_name, $170, b.foreign_data_wrapper_name, $171, b.foreign_data_wrapper_handler, $172, coalesce(c.columns, $173::jsonb) ) end as entity from base_table_info b left join table_stats ts on b.id = ts.id left join primary_keys pk on b.id = pk.table_id left join unique_indexes ui on b.id = ui.table_id left join columns c on b.id = c.table_id",
    "rolname": "postgres",
    "calls": 115,
    "mean_time": 12.4777424695652,
    "min_time": 7.682708,
    "max_time": 62.09221,
    "total_time": 1434.940384,
    "rows_read": 115,
    "cache_hit_rate": "100.0000000000000000",
    "prop_total_time": 0.7716602345265828,
    "index_advisor_result": null
  },
  {
    "query": "INSERT INTO \"sessions\" (\"aal\", \"created_at\", \"factor_id\", \"id\", \"ip\", \"not_after\", \"oauth_client_id\", \"refresh_token_counter\", \"refresh_token_hmac_key\", \"refreshed_at\", \"scopes\", \"tag\", \"updated_at\", \"user_agent\", \"user_id\") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)",
    "rolname": "supabase_auth_admin",
    "calls": 129,
    "mean_time": 8.85466051937985,
    "min_time": 0.11251,
    "max_time": 36.091813,
    "total_time": 1142.251207,
    "rows_read": 129,
    "cache_hit_rate": "99.8214883409572688",
    "prop_total_time": 0.6142623373835525,
    "index_advisor_result": null
  },
  {
    "query": "WITH\n-- Recursively get the base types of domains\nbase_types AS (\n  WITH RECURSIVE\n  recurse AS (\n    SELECT\n      oid,\n      typbasetype,\n      typnamespace AS base_namespace,\n      COALESCE(NULLIF(typbasetype, $2), oid) AS base_type\n    FROM pg_type\n    UNION\n    SELECT\n      t.oid,\n      b.typbasetype,\n      b.typnamespace AS base_namespace,\n      COALESCE(NULLIF(b.typbasetype, $3), b.oid) AS base_type\n    FROM recurse t\n    JOIN pg_type b ON t.typbasetype = b.oid\n  )\n  SELECT\n    oid,\n    base_namespace,\n    base_type\n  FROM recurse\n  WHERE typbasetype = $4\n),\ncolumns AS (\n    SELECT\n        c.oid AS relid,\n        a.attname::name AS column_name,\n        d.description AS description,\n        -- typbasetype and typdefaultbin handles `CREATE DOMAIN .. DEFAULT val`,  attidentity/attgenerated handles generated columns, pg_get_expr gets the default of a column\n        CASE\n          WHEN (t.typbasetype != $5) AND (ad.adbin IS NULL) THEN pg_get_expr(t.typdefaultbin, $6)\n          WHEN a.attidentity  = $7 THEN format($8, seq.objid::regclass)\n          WHEN a.attgenerated = $9 THEN $10\n          ELSE pg_get_expr(ad.adbin, ad.adrelid)::text\n        END AS column_default,\n        not (a.attnotnull OR t.typtype = $11 AND t.typnotnull) AS is_nullable,\n        CASE\n            WHEN t.typtype = $12 THEN\n            CASE\n                WHEN bt.base_namespace = $13::regnamespace THEN format_type(bt.base_type, $14::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n            ELSE\n            CASE\n                WHEN t.typnamespace = $15::regnamespace THEN format_type(a.atttypid, $16::integer)\n                ELSE format_type(a.atttypid, a.atttypmod)\n            END\n        END::text AS data_type,\n        format_type(a.atttypid, a.atttypmod)::text AS nominal_data_type,\n        information_schema._pg_char_max_length(\n            information_schema._pg_truetypid(a.*, t.*),\n            information_schema._pg_truetypmod(a.*, t.*)\n        )::integer AS character_maximum_length,\n        bt.base_type,\n        a.attnum::integer AS position\n    FROM pg_attribute a\n        LEFT JOIN pg_description AS d\n            ON d.objoid = a.attrelid and d.objsubid = a.attnum and d.classoid = $17::regclass\n        LEFT JOIN pg_attrdef ad\n            ON a.attrelid = ad.adrelid AND a.attnum = ad.adnum\n        JOIN pg_class c\n            ON a.attrelid = c.oid\n        JOIN pg_type t\n            ON a.atttypid = t.oid\n        LEFT JOIN base_types bt\n            ON t.oid = bt.oid\n        LEFT JOIN pg_depend seq\n            ON seq.refobjid = a.attrelid and seq.refobjsubid = a.attnum and seq.deptype = $18\n    WHERE\n        NOT pg_is_other_temp_schema(c.relnamespace)\n        AND a.attnum > $19\n        AND NOT a.attisdropped\n        AND c.relkind in ($20, $21, $22, $23, $24)\n        AND c.relnamespace = ANY($1::regnamespace[])\n),\ncolumns_agg AS (\n  SELECT\n    relid,\n    array_agg(row(\n      column_name,\n      description,\n      is_nullable::boolean,\n      data_type,\n      nominal_data_type,\n      character_maximum_length,\n      column_default,\n      coalesce(\n        (SELECT array_agg(enumlabel ORDER BY enumsortorder) FROM pg_enum WHERE enumtypid = base_type),\n        $25\n      )\n    ) order by position) as columns\n  FROM columns\n  GROUP BY relid\n),\ntbl_pk_cols AS (\n  SELECT\n    r.oid AS relid,\n    array_agg(a.attname ORDER BY a.attname) AS pk_cols\n  FROM pg_class r\n  JOIN pg_constraint c\n    ON r.oid = c.conrelid\n  JOIN pg_attribute a\n    ON a.attrelid = r.oid AND a.attnum = ANY (c.conkey)\n  WHERE\n    c.contype in ($26)\n    AND r.relkind IN ($27, $28)\n    AND r.relnamespace NOT IN ($29::regnamespace, $30::regnamespace)\n    AND NOT pg_is_other_temp_schema(r.relnamespace)\n    AND NOT a.attisdropped\n  GROUP BY r.oid\n)\nSELECT\n  n.nspname AS table_schema,\n  c.relname AS table_name,\n  d.description AS table_description,\n  c.relkind IN ($31,$32) as is_view,\n  (\n    c.relkind IN ($33,$34)\n    OR (\n      c.relkind in ($35,$36)\n      -- The function `pg_relation_is_updateable` returns a bitmask where 8\n      -- corresponds to `1 << CMD_INSERT` in the PostgreSQL source code, i.e.\n      -- it's possible to insert into the relation.\n      AND (pg_relation_is_updatable(c.oid::regclass, $37) & $38) = $39\n    )\n  ) AS insertable,\n  (\n    c.relkind IN ($40,$41)\n    OR (\n      c.relkind in ($42,$43)\n      -- CMD_UPDATE\n      AND (pg_relation_is_updatable(c.oid::regclass, $44) & $45) = $46\n    )\n  ) AS updatable,\n  (\n    c.relkind IN ($47,$48)\n    OR (\n      c.relkind in ($49,$50)\n      -- CMD_DELETE\n      AND (pg_relation_is_updatable(c.oid::regclass, $51) & $52) = $53\n    )\n  ) AS deletable,\n  coalesce(tpks.pk_cols, $54) as pk_cols,\n  coalesce(cols_agg.columns, $55) as columns\nFROM pg_class c\nJOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_description d on d.objoid = c.oid and d.objsubid = $56 and d.classoid = $57::regclass\nLEFT JOIN tbl_pk_cols tpks ON c.oid = tpks.relid\nLEFT JOIN columns_agg cols_agg ON c.oid = cols_agg.relid\nWHERE c.relkind IN ($58,$59,$60,$61,$62)\nAND c.relnamespace NOT IN ($63::regnamespace, $64::regnamespace)\nAND not c.relispartition\nORDER BY table_schema, table_name",
    "rolname": "authenticator",
    "calls": 94,
    "mean_time": 11.3630255957447,
    "min_time": 1.206786,
    "max_time": 62.246921,
    "total_time": 1068.124406,
    "rows_read": 3522,
    "cache_hit_rate": "99.6651595290905989",
    "prop_total_time": 0.574399563095387,
    "index_advisor_result": null
  }
]